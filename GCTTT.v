
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module GCTTT(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// GPIO_1, GPIO_1 connect to D5M - 5M Pixel Camera //////////
	input 		    [11:0]		D5M_D,
	input 		          		D5M_FVAL,
	input 		          		D5M_LVAL,
	input 		          		D5M_PIXCLK,
	output		          		D5M_RESET_N,
	output		          		D5M_SCLK,
	inout 		          		D5M_SDATA,
	input 		          		D5M_STROBE,
	output		          		D5M_TRIGGER,
	output		          		D5M_XCLKIN
);



//=======================================================
//  REG/WIRE declarations
//=======================================================
wire				DLY_RST_0;
wire				DLY_RST_1;
wire				DLY_RST_2;
wire				DLY_RST_3;
wire				DLY_RST_4;

reg [11:0]			rccd_DATA;
reg					rccd_LVAL;
reg					rccd_FVAL;

wire [15:0]			X_Cont;
wire [15:0]			Y_Cont;
wire [31:0]			Frame_Cont;

wire start;

wire [3:0]			loc;
wire 				interrupt;
wire				dccd_DVAL;
reg				cpu_int;
reg				prev_int;
reg [3:0]		prev_loc;

wire [31:0]		pixel_addr;
wire			pixel_value;
wire			pixel_en;
wire			int_ack;

reg frame_en;

wire [18:0]		buff_addr;
wire			out_data;

wire	       [11:0]			sCCD_R;
wire	       [11:0]			sCCD_G;
wire	       [11:0]			sCCD_B;
wire							sCCD_DVAL;

wire			 [15:0]			Read_DATA1;
wire	       [15:0]			Read_DATA2;
wire								Read;

wire	       [9:0]			oVGA_R;   				//	VGA Red[9:0]
wire	       [9:0]			oVGA_G;	 				//	VGA Green[9:0]
wire	       [9:0]			oVGA_B;   				//	VGA Blue[9:0]

//=======================================================
//  Structural coding
//=======================================================
// D5M
assign D5M_TRIGER = 1'b1;
assign D5M_RESET_N = DLY_RST_1;

assign LEDR = {cpu_int, 5'h00, loc};

// auto start when power on
assign start = ((KEY[0]) && (DLY_RST_3) && (!DLY_RST_4)) | !KEY[3];

//fetch the high 8 bits
assign  VGA_R = oVGA_R[9:2];
assign  VGA_G = oVGA_G[9:2];
assign  VGA_B = oVGA_B[9:2];

// D5M read
always @(posedge D5M_PIXCLK) begin
	rccd_DATA <= D5M_D;
	rccd_FVAL <= D5M_FVAL;
	rccd_LVAL <= D5M_LVAL;
end

Reset_Delay		reset(.iCLK(CLOCK_50),
				      .iRST(KEY[0]),
					  .oRST_0(DLY_RST_0),
					  .oRST_1(DLY_RST_1),
					  .oRST_2(DLY_RST_2),
					  .oRST_3(DLY_RST_3),
					  .oRST_4(DLY_RST_4)
					  );

always @(posedge D5M_PIXCLK) begin
	if (!KEY[0])
		prev_loc <= 4'hF;
	else if (interrupt)
		prev_loc <= loc;
end
					  
always @(posedge D5M_PIXCLK) begin
	if (!KEY[0])
		cpu_int <= 1'b0;
	else if (!KEY[1])
		cpu_int <= 1'b0;
	else if (interrupt & !cpu_int);
		cpu_int <= 1'b0;
end

always @(posedge D5M_PIXCLK) begin
	if (!KEY[0])
		prev_int <= 1'b0;
	else
		prev_int <= interrupt;
end

IPU				ipu(.D5M_PIXLCLK(D5M_PIXCLK),
					.CLOCK2_50(CLOCK2_50),
					.DLY_RST_1(DLY_RST_1),
					.DLY_RST_2(DLY_RST_2),
					
					// CCD_Capture
					.rccd_DATA(rccd_DATA),
					.rccd_FVAL(rccd_FVAL),
					.rccd_LVAL(rccd_LVAL),
					.iSTART(start),
					.iEND(!KEY[2]),
					.X_Cont(X_Cont),
					.Y_Cont(Y_Cont),
					.Frame_Cont(Frame_Cont),
					
					// imgdetect
					.loc(loc),
					.interrupt(interrupt),
					.dccd_DVAL(dccd_DVAL),
					
					// I2C
					.D5M_SCLK(D5M_SCLK),
					.D5M_SDATA(D5M_SDATA)
					);

sdram_pll		clock(.refclk(CLOCK_50),
					  .rst(1'b0),
					  .outclk_0(sdram_ctrl_clk),
					  .outclk_1(DRAM_CLK),
					  .outclk_2(D5M_XCLKIN),
					  .outclk_3(VGA_CLK),
					  );
					  
proc			PROC0(.clk(D5M_PIXCLK), 
					  .rst(!KEY[0]), 
					  .leds(), 
					  .pixel_addr(pixel_addr), 
					  .pixel_value(pixel_value),
					  .pixel_en(pixel_en),
					  .ipu_int(interrupt),
					  .int_ack(int_ack),
					  .grid_coord(loc)
					  );

always @(posedge D5M_PIXLCLK, negedge DLY_RST_1) begin
	if (!DLY_RST_1)
		frame_en <= 1'b1;
	else if (interrupt)
		frame_en <= 1'b1;
	else if (!Frame_Cont[0] & |Frame_Cont)
		frame_en <= 1'b0;
end

assign buff_addr = frame_en ? pixel_addr : (X_Cont[10:1] + Y_Cont[10:1] * 640);

frame_buffer	buffer(.address(buff_addr), .clock(D5M_PIXCLK), .data(pixel_value), .wren(frame_en & pixel_en), .q(out_data));

assign {sCCD_R,sCCD_G,sCCD_B,sCCD_DVAL} = {{36{out_data}},dccd_DVAL};

//SDRam Read and Write as Frame Buffer
Sdram_Control	   u7	(	//	HOST Side						
						   .RESET_N(KEY[0]),
							.CLK(sdram_ctrl_clk),

							//	FIFO Write Side 1
							.WR1_DATA({1'b0,sCCD_G[11:7],sCCD_B[11:2]}),
							.WR1(sCCD_DVAL & ~frame_en),
							.WR1_ADDR(0),
                     .WR1_MAX_ADDR(640*480),
						   .WR1_LENGTH(8'h50),
		               .WR1_LOAD(!DLY_RST_0),
							.WR1_CLK(~D5M_PIXLCLK),

							//	FIFO Write Side 2
							.WR2_DATA({1'b0,sCCD_G[6:2],sCCD_R[11:2]}),
							.WR2(sCCD_DVAL & ~frame_en),
							.WR2_ADDR(23'h100000),
							.WR2_MAX_ADDR(23'h100000+640*480),
							.WR2_LENGTH(8'h50),
							.WR2_LOAD(!DLY_RST_0),				
							.WR2_CLK(~D5M_PIXLCLK),

                     //	FIFO Read Side 1
						   .RD1_DATA(Read_DATA1),
				        	.RD1(Read),
				        	.RD1_ADDR(0),
                     .RD1_MAX_ADDR(640*480),
							.RD1_LENGTH(8'h50),
							.RD1_LOAD(!DLY_RST_0),
							.RD1_CLK(~VGA_CTRL_CLK),
							
							//	FIFO Read Side 2
						   .RD2_DATA(Read_DATA2),
							.RD2(Read),
							.RD2_ADDR(23'h100000),
                     .RD2_MAX_ADDR(23'h100000+640*480),
							.RD2_LENGTH(8'h50),
                   	.RD2_LOAD(!DLY_RST_0),
							.RD2_CLK(~VGA_CTRL_CLK),
										
							//	SDRAM Side
						   .SA(DRAM_ADDR),
							.BA(DRAM_BA),
							.CS_N(DRAM_CS_N),
							.CKE(DRAM_CKE),
							.RAS_N(DRAM_RAS_N),
							.CAS_N(DRAM_CAS_N),
							.WE_N(DRAM_WE_N),
							.DQ(DRAM_DQ),
							.DQM({DRAM_UDQM,DRAM_LDQM})
						   );
						   
//VGA DISPLAY
VGA_Controller	  u1	(	//	Host Side
							.oRequest(Read),
							.iRed(Read_DATA2[9:0]),
					      .iGreen({Read_DATA1[14:10],Read_DATA2[14:10]}),
						   .iBlue(Read_DATA1[9:0]),
						
							//	VGA Side
							.oVGA_R(oVGA_R),
							.oVGA_G(oVGA_G),
							.oVGA_B(oVGA_B),
							.oVGA_H_SYNC(VGA_HS),
							.oVGA_V_SYNC(VGA_VS),
							.oVGA_SYNC(VGA_SYNC_N),
							.oVGA_BLANK(VGA_BLANK_N),
							//	Control Signal
							.iCLK(VGA_CTRL_CLK),
							.iRST_N(DLY_RST_2),
							.iZOOM_MODE_SW(SW[9])
						   );


endmodule


